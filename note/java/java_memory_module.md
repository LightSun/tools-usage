//http://www.infoq.com/cn/articles/java-memory-model-1
# java内存模型
* 1, 在java中所有的实例域，静态域，数组元素存储在堆内存中，堆内存在线程之间共享。
本地变量，参数，异常处理等不共享.
每个线程都有自己私有的本地内存(JMM)。 本地内存并不真实存在.它涵盖了缓存，写缓冲区，寄存器以及其他硬件和编译器的优化。

* 2,线程之间共享要经历2个步骤(假设俩线程，A写，B读)。
    * 1）A线程把更新后的共享变量刷新到主存上。
	* 2）B读的线程从主存读取已经更新后的共享变量
	
	
# 重排
* 1 编译器优化的重排
* 2,指令级别重排.
* 3, 内存系统的重排
* 详解：<br>
1 属于编译器重排， 2，3所以处理器重排. 他们都可能导致内存可见性问题。
对于编译器重排，jmm的编译器重排规则会禁止特性类型的编译器重排（不是所有编译器）。
对于处理器重排, JMM处理器会要求java生成内存屏障指令，以禁止特定类型的处理器重排.

JMM属于语言级的内存模型, 它确保在不同的编译器和不同的处理器平台之上，
通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。

现代的处理器使用写缓冲区来临时保存向内存写入的数据


# happen-before
程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。
监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。
volatile变量规则：对一个volatile域的写，happens- before 于任意后续对这个volatile域的读。
传递性：如果A happens- before B，且B happens- before C，那么A happens- before C。